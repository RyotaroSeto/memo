# 物理設計

データベースを効率よく運用するためには、各ファイルをどこに、どのように格納するかといった物理的な面を考慮した設計が重要

## テーブルファイル

- テーブルファイルのサイズは次のタイミングで増加する
    - データの挿入時
    - データ更新時に既存の再利用可能な領域が使用できず、新規ページが追加された場合
- テーブルファイルのサイズは次のタイミングで減少する
    - DROP TABLEでテーブル自体を削除した場合
    - TRUNCATE TABLEでテーブル全体を空化した場合
    - CLUSTERでテーブルをインデックス順に再構成した場合
    - VACUUM FULLを実行した場合

## インデックスファイル

- インデックスファイルのサイズは次のタイミングで増加する
    - データの挿入時
    - データ更新時に既存の再利用可能な領域が使用できず、新規ページが追加された場合
- インデックスファイルのサイズは次のタイミングで減少する
- DROP INDEXでテーブル自体を削除した場合
- TRUNCATE TABLEでテーブル全体を空化した場合
- REINDEXでインデックスを再構成した場合

## テーブルファイルに対するアクセス

テーブルに対するアクセスは大きく分けて以下2つ

- シーケンシャルアクセス
    - テーブルファイルのすべてのページを順々に参照するアクセス方法で、条件を与えない検索やインデックスを使用しない場合行われる。
- インデックスアクセス
    - インデックスファイル内に格納されたインデックスを辿り、インデックスのリーフに設定されたテーブルファイルへのポインタからテーブルファイルの特定のページを取得する

## WALファイル

- WALファイルは先行書き込みをログが格納される重要なファイル。PostgreSQLに対して更新要求があった場合、まず更新のログをWALバッファに書き込む。そしてトランザクションがコミットされる。あるいは更新量が多いためWALバッファが溢れる場合、WALバッファの内容がWALファイルに書き込まれる
- WALファイルの総ファイルサイズ上限はpostgresの設定パラメータ「max_wal_size」で決定する
- WALファイルの領域は少なくともmax_wal_size分の容量が必要。max_wal_sizeの値はチェックポイントが動作するタイミングを制御するものでもある。
- レプリケーション構成の場合はwal_keep_sizeの設定も考慮したWALファイル領域の容量を設計する必要がある。また、アーカイブファイルの取得に失敗するケースなどでは上限を超える可能性があることに注意。
- WALファイルは増え続けるものではなく、以下の契機で再利用または削除される
    - アーカイブされたWALファイルは不要となり、チェックポイント契機で再利用または削除される。再利用というのはWALファイル自体は削除せず、今後発生するWALの書き込み用のファイルとして残し、新たにWALの書き込みが発生する契機でWALファイルをリネームして上書きする動きを指す。
    - またmin_wal_sizeの設定がmax_wal_sizeよりも小さい場合、チェックポイント契機でmin_wal_sizeを超えるWALサイズは削除される

## アーカイブファイル

- アーカイブファイルは、ポイントインタイムリカバリで必要となる過去の更新ログファイル。
- アーカイブファイルはPostgreSQLの設定でアーカイブモードを有効にしているときにWALファイルのコピーとして生成される
- アーカイブファイルはWALファイルとは異なり、循環的に利用することはないためディスク上限まで増加する。アーカイブファイル格納領域がディスク上限に達した場合、WALファイルのアーカイブ化が失敗する。アーカイブ化が失敗した場合、WALファイルは再利用されず、WALファイル格納領域に残ったままとなる。このまま更新が継続すると、WALファイル格納領域がディスク上限に達してしまいPostgreSQLはpanicを起こし停止する。そうなる前にアーカイブファイル格納領域の空きを作る必要がある

## HOTとFILLFACTOR   ヒゲ予約

### HOT

- postgresSQL8.3からHOT(Heap Only Tuple)が導入されPostgreSQLの更新性能が大幅に向上。
- HOTによりバキュームの対象となる不要領域そのものの発生量が減少
- HOTは以下の処理を行うことで更新性能を向上させている
    - UPDATE時のインデックスエントリの追加処理をスキップ
    - VACUUM処理を待つことなく不要領域を再利用可能にする
- HOTが有効になるのは、インデックスを持たない列への更新時で、更に更新対象の行と同じページ内に空きがあり、新しい行を挿入可能な場合。空きがない場合はHOT更新せず、新規にページを払いだして行を挿入する
- 以下のような更新処理の場合、HOTは働かない
    - DELETE + INSERTのような更新シーケンス
    - インデックス列を更新するUPDATE
    - 一度に大量の行を更新するようなUPDATE

### FILLFACTOR

- FILLFACTORはページ内の空き領域をどの程度データ挿入用に利用するかを示すパラメータ
    - パラメータを小さくすると、挿入時に使用できる領域は減るが、更新時に空き領域を有効活用できる
    - FILLFACTORのデフォルト値はテーブルでは「100%」、インデックスでは「90%」
    - FILLFACTOR値は以下の考え方で設定する
        - 該当テーブルに対する更新や削除がない場合は「100%」のままとする
        - 更新がある場合、該当テーブルの平均的なレコード長の2倍程度の空き容量を確保するように設定する
        - FILLFACTORはあまり小さくしすぎると各ページで多くの空き領域を抱えることになり無駄が生じる。一般的にFILLFACTORの下限は70%程度が適切と考えられる
- FILLFACTORの確認方法
    - FILLFACTORはcreate tableコマンド時や、alter tableコマンドを使って変更できる
    - FILLFACTOR値はpg_classシステムカタログのreloptionsという列に「fillfactor=数値」という書式で格納されている
    - 以下のようなクエリで確認する(設定していない場合空白になる)

    ```sql
    SELECT nspname as schema, relname, relkind, reloptions, FROM pg_class c LEFT JOIN pg_namespace n ON relnamespace = n.oid WHERE relkind in ('i','r') AND nspname = 'public'
    ```
