## データベース接続通信の流れ

1. クライアントプロセスは最初にマスタサーバのポートに対してユーザ名と接続したいデータベース名を含むメッセージを送信する
2. マスタサーバはそのメッセージ内の情報と、pg_hba.conf の内容を比較して、接続が許容されてるか確認する
3. 該当する接続が認証を必要とする場合は、認証を要求するメッセージをクライアントに送信し、クライアントは認証に必要な情報をサーバに送信する(認証を必要としない場合、trust などはこの処理をスキップ)
4. サーバは認証情報を受け取ると、認証方式に従った処理を行う
5. 認証が成功すれば認証成功のメッセージをクライアントプロセスに返却し、バックエンドプロセスを fork()により生成する
6. マスタサーバはバックエンドプロセスの起動を行った後、クライアントプロセスに開始処理終了のメッセージを送信。クライアントプロセスは認証成功メッセージを受信した後、マスタサーバから開始処理終了のメッセージを受け取るまで待機。開始処理終了のメッセージを受信すると、接続が確立されたことになり、クライアントサーバからクエリを送信することが可能になる

- psql によるサーバへのアクセス時や、libpq/JDBC ライブラリを使用してサーバへアクセスする時はライブラリ内でこうしたメッセージ処理を行っている

## SQL 文実行までの流れ

1. パーサを実行する(以下)
   1. 字句解析
      1. 拡張子が「.l」のファイル内容に基づき、SQL 文を識別子や SQL キーワードなどのトークンに分解して構文解析に移る
   2. 構文解析
      1. 字句解析で分解された字句の並びが PostgreSQL で扱える SQL の記述規則に合っているか検査して問い合わせツリーを生成する。また、拡張子が「.y」のファイル内容に基づき、渡された SQL が PostgreSQL で規定された構文に合っているかをチェックする
   3. 実行するかの確認
      1. 字句解析、構文解析に加えて、パーサは問い合わせツリーの内容から、テーブル名や列名が実際にデータベースに存在するか(アクセスできるか)を判断する。妥当な SQL だと解析されると「問い合わせツリー」を生成し、次のリライタに渡す
2. リライタ
   1. SQL を実行する DB にルール(SQL を書き換える規則)が定義されている場合、そのルールを参照してリライタで問い合わせツリーを修正する。修正した問い合わせツリーは次の処理のプランナに渡す
3. プランナ/オプティマイザ
   1. リライタで修正された問い合わせツリーを元に適切な実行計画を生成する。実行計画の生成には大きく 2 つの段階がある
      1. 個々のテーブルに対するアクセス方法の選択
         1. まず、テーブル全体をスキャンする方式を検索方式の候補とする。問い合わせ中にそのテーブルに対する検索条件が設定され、かつそのテーブルに設定されたインデックスが使用可能であれば、インデックス検索やビットマップ検索を検索方式の候補とする
      2. 結合方法の選択
         1. 問い合わせツリーが複数のテーブルを対象とする場合は結合方法を選択する。PostgreSQL は「入れ子ループ結合」「マージ結合」「ハッシュ結合」の 3 つの結合方法をサポートしており、プランナではこの 3 つから適用可能な結合方法を統計情報をもとに判断する。また、結合対象となるテーブルが 3 つ以上の場合、結合の順序も考慮される。個々のテーブルに対するアクセス方法、結合方法、結合順序の組み合わせの候補群から最も効率が良いと判断した方法の組み合わせが実行計画として生成され、エグゼキュータに渡される。
            1. なお、プランナで生成した実行計画は EXPLAIN コマンドで確認できる
4. エグゼキュータ
   1. プランナで決定された実行計画に従って必要な行の集合を抽出する。

## トランザクション

### トランザクションの分離レベル

- トランザクションは同時に1つだけ実行されるとは限らず、複数のトランザクションが同時に実行された場合に、それぞれのトランザクション間で相互に与える影響度合いをトランザクションの分離レベルという。
- トランザクションの分離レベルが弱い(他のトランザクションの影響を受けやすい)場合、以下の影響が発生する
    - ダーティリード
        - 同時に実行されている他のトランザクションが書き込んだコミット前のデータを読み込んでしまう
        - リードコミッティドで抑止可能
    - 反復不能読み取り
        - 同一トランザクション内で一度読み込みを行い、2回目の読み込みの間に、別トランザクションで更新とコミットがされた場合、その別トランザクションの影響を受け、値が変わってしまう
        - リピータブルリードで抑止可能
    - ファントムリード
        - 同一トランザクション内で一度読み込みを行い、2回目の読み込みの間に、別トランザクションで挿入とコミットがされた場合、その別トランザクションの影響を受け、検索結果が変わってしまう。
        - シリアライザブルで抑止可能
- PostgreSQLは分離レベルが比較的低いリードコミッティをデフォルト挙動としている
- PostgreSQL拡張機能contrib/postgres_fdwモジュール内で実行されるリモートトランザクションはリピータブルリードまたはシリアライザブル
- 以下トランザクション分離レベル

| 分離レベル | 意味 | PostgreSQLでの扱い |
| --- | --- | --- |
| リードアンコミッティド | コミットされていないデータが参照される可能性がある | この指定を行っても、リードコミッティドとして扱う |
| リードコミッティド | 問い合わせが実行される直前までにコミットされたデータのみを参照する | デフォルト |
| リピータブルリード | トランザクションが開始される前までにコミットされたデータのみを参照する。単一トランザクション内の連続するselectコマンドは、常に同じデータを参照する |  |
| シリアライザブル | 最も厳しいトランザクション分離レベル。並列実行された複数のトランザクションの実行であっても、逐次的に扱われたものと同じ結果を要求される |  |

## ロック

- トランザクションから同時実行を確実にするため、テーブル/行に対して明示的なロックを獲得できる。
    - テーブル単位のロックはLOCKコマンド
    - 行単位のロックはselectコマンドのオプション指定でselect for updateまたはselect for share

| ロックモード | 獲得タイミング |
| --- | --- |
| ACCESS SHARE | selectによる参照で獲得される |
| ROW SHARE | select for update, select for share, for no key update, for key share で獲得される |
| ROW EXCLUSIVE | insert, update , deleteで獲得される |
| SHARE UPDATE EXCLUSIVE | vacuum, analyze, create index concurrently, およびalter table, set, reset, validate constraint, cluster on, set without clusterで獲得される |
| SHARE | create index実行のタイミングで獲得される |
| SHARE ROW EXCLUSIVE | 同一セッション内での競合を防止するためのロックモード。明示的にこのロックモードを獲得するコマンドはない |
| EXCLUSIVE | 明示的にこのロックモードを獲得するコマンドはない |
| ACCESS EXCLUSIVE | alter table, drop table truncate, reindex, cluster, vacuum fullで獲得される。lock tableコマンド発行時のデフォルトのロックモード |
- またロックモードによって競合するものとしないものがある
