## グレーゾーン

- そもそも入力データに主キーにできるような一意キーが存在しない場合
    - そもそもそんなデータをテーブルに投入するべきではない。前段階のアプリケーションできちんとレコードを一意にして綺麗な状態にしてからDBに投入すべき
- 一意キーではあるが使いまわされたり、途中で指す対象が変化する場合は代理キーで対応する
    - 代理キー(サロゲートキー)
        - 入力データに最初から存在しているキーの代理として新たに追加するキー
        - 主キーが多くのキーからなる複合キーの場合、SQLのwhere句における条件記述をシンプルにできるメリットもある
        - しかし、一般的な原則として、極力代理キーの使用は避けて、自然キーによる解決を図るべき。
            - 理由として、代理キーがそもそも論理的には不要なキーのため、論理モデルをわかりにくくしてしまうため。
- オートナンバリング機能
    - 自然キーが不可能なら代理キーとして使用はあり
    - 種類は以下2つがある。ID列はDBMSごとに実装が統一されておらず、移植性が低い理由から使用するなら、シーケンスを推奨
        - シーケンスオブジェクト
        - ID列(mysqlだとauto_increment,postgresだとserial)
    - その他アプリケーション側で実装することによって、オートナンバリングを実現できる
        - この場合は1人がテーブルにアクセスした時点でテーブルをロックする必要がある
            - シーケンスオブジェクトなら最初からこのような処理が実装されている
            - よって、オートナンバリングをアプリケーションで実装することは車輪の再発明
    - オートナンバリングの最大のデメリットとしてロックが起きることで同時アクセスが多数発生した時に、この連番の払い出し処理がボトルネックとなり、性能遅延が発生する恐れがある
- 一時テーブルのデメリット
    - 統計情報の収集タイミングが難しい
        - SQL文を実行する時、テーブルやインデックスに含まれるデータの統計情報をもとに実行計画(アクセスパス)を決定する。そのため、統計情報が古く、最新おデータ状態と乖離がある場合、最適な実行計画が作成されず性能問題の原因となる。一時テーブルは通常は空っぽで１行のレコードももっていないためこの状態で統計情報を収集しても無意味。それどころか大量のレコードを一気に投入されたにも関わらず、DBMSが0行と判断して実行計画を組み立てることは有害。
        - そのため一時テーブルの統計情報は必要なデータがinsertされた後に収集する必要がある
    - 物理的なI/O分散が難しい
        - 一時テーブルはデータファイルとして作られず、一時ファイルとして作られる。そのためデータファイルの最も高性能なスペックのストレージの恩恵が受けられない。
    - 上記の理由のため一時テーブルを使用する時はかなり性能的に厳しい条件下での設計が求められることを覚えておく
- レプリケーション
    - 全く同じデータを持つDBを2セット用意して、常に一方の更新差分をもう一方に反映することで同期を取る仕組み。この時、主としてユーザーが利用する方をマスタ、もう一方の更新差分で更新していく方をスレーブと呼ぶ。
    - レプリケーションの利点は障害児の復旧に要する時間が短いこと。
    - 欠点はコスト。dbを最低2セット用意するため
