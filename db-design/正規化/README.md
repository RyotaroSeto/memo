## テーブルの構成要素

- 社員テーブルと部署テーブルがあり、子と親の関係
  - 親でる部署テーブルのレコードが変更されたり削除されたりした場合、子の社員テーブルは、合わせて削除するか、それとも削除 SQL 文をエラーにするか選択可能
    - この合わせて削除する動作を「カスケード」と呼ぶ
  - 一番良いのは常に子のテーブルを先に削除または変更して、後から親テーブルを更新すること。
- キーを使用する列は、文字列などでなく、必ず何らかのコードや ID といった表記体系のきっちり定まったデータを固定長文字列のデータ型に格納して使う。
- NOT NULL 制約
  - 可能な限りデータは NULL にしないこと(NOT NULL 制約)がデータベース設計における大方針
- 一意制約
  - ある列の組みについて一意性を求める制約。一意制約は何個でも設定できる
- CHECK 制約
  - ある列のとりうる値の範囲を制限するための制約。例えば年齢なら「20~65 までの整数」など。何個でも設定できる
- テーブルと列の名前に使える文字
  - 半角アルファベット
  - 半角数字
  - アンダーバー

## 第 1 正規形

### テーブル 1

| 社員 ID | 社員名 | 子 1 | 子 2 |
| ------- | ------ | ---- | ---- |
| 1       | 加藤   | 太郎 | 洋子 |
| 2       | 山田   | 敦   |      |
| 3       | 藤田   |      |      |

### テーブル 2

| 社員 ID | 社員名 | 子   |
| ------- | ------ | ---- |
| 1       | 加藤   | 太郎 |
| 1       | 加藤   | 子   |
| 2       | 山田   | 敦   |
| 3       | 藤田   |      |

- 基本的にテーブル 2 のようにすることが望ましい
- 藤田の子は NULL になってしまうため、子を持っていない社員の「子」列には、特定の文字列、例えば’子なし’を入れるという業務ルールを作る方法もある
- ちなみにこのテーブルは以下のように、社員テーブル、扶養者テーブルと分けるべき

### 社員テーブル

| 社員 ID | 社員名 |
| ------- | ------ |
| 1       | 加藤   |
| 2       | 山田   |
| 3       | 藤田   |

### 扶養者テーブル

| 社員 ID | 子   |
| ------- | ---- |
| 1       | 太郎 |
| 1       | 花子 |
| 2       | 敦   |
| 2       | 涼太 |

- 扶養者テーブルについては子を持っている社員のレコードのみ限定して保持することで、主キーが NULL になる自体を防止できる
- 子を持たない藤田さんの情報が欠落するが、これについては社員テーブルで管理するようにすれば、子の有無に関わらず、社員全員の情報を保持することが可能になる。SQL のイメージは以下

```sql
SELECT 社員.社員ID,
       社員.社員名,
       扶養者.子
  FROM 社員 INNER JOIN 扶養者
    ON 社員.社員ID = 扶養者.社員ID;

社員ID  社員名  子
-----   ----  ---
1       加藤   太郎
1       加藤   花子
2       山田   敦
2       山田   涼太
```

- 藤田さんを含めたければ、内部結合を外部結合に変える SQL イメージは以下

```sql
SELECT 社員.社員ID,
       社員.社員名,
       扶養者.子
  FROM 社員 LEFT OUTER JOIN 扶養者
    ON 社員.社員ID = 扶養者.社員ID;

社員ID  社員名  子
-----   ----  ---
1       加藤   太郎
1       加藤   花子
2       山田   敦
2       山田   涼太
3       藤田
```

## 第二正規形

| 会社コード | 会社名 | 社員 ID | 社員名 |
| ---------- | ------ | ------- | ------ |
| 1          | A 商事 | 000A    | 加藤   |
| 1          | A 商事 | 000B    | 藤本   |
| 2          | B 化学 | 000A    | 三島   |
| 2          | B 化学 | 000B    | 斉藤   |

- 上記テーブルの主キーは会社コード、社員 ID。
- しかし、会社名だけ主キーの一部である会社コードに従属している。部分関数従属である
- 以下のように修正する

### 社員テーブル

| 会社コード | 社員 ID | 社員名 |
| ---------- | ------- | ------ |
| 1          | 000A    | 加藤   |
| 1          | 000B    | 藤本   |
| 2          | 000A    | 三島   |
| 2          | 000B    | 斉藤   |

### 会社テーブル

| 会社コード | 会社名 |
| ---------- | ------ |
| 1          | A 商事 |
| 2          | B 化学 |

- 正規化のメリット
  - 正規化する前の社員テーブルを見ると、社員情報が不明な会社(C 建設)があった場合、この会社をテーブルに登録できない。社員 ID に一時的なダミー値を入れる逃げてもあるが、根本的な解決になっていない。
  - 例えば正規化する前の社員テーブルで、{1,A 商事}の他に{1,A 商社}と間違ってデータが登録される危険がある
- **第二正規化というのは異なるレベルの実体(エンティティ)をきちんとテーブルとしても分離**すること

## 第 3 正規形

### 社員テーブル

| 会社コード | 社員 ID | 社員名 | 年齢 | 部署コード | 部署名 |
| ---------- | ------- | ------ | ---- | ---------- | ------ |
| 1          | 000A    | 加藤   | 40   | D01        | 開発   |
| 1          | 000B    | 藤本   | 32   | D02        | 人事   |
| 2          | 000A    | 三島   | 33   | D01        | 開発   |
| 2          | 000B    | 斉藤   | 44   | D03        | 営業   |

### 会社テーブル

| 会社コード | 会社名 |
| ---------- | ------ |
| 1          | A 商事 |
| 2          | B 化学 |

- 第 3 正規化すると以下

### 社員テーブル

| 会社コード | 社員 ID | 社員名 | 年齢 | 部署コード |
| ---------- | ------- | ------ | ---- | ---------- |
| 1          | 000A    | 加藤   | 40   | D01        |
| 1          | 000B    | 藤本   | 32   | D02        |
| 2          | 000A    | 三島   | 33   | D01        |
| 2          | 000B    | 斉藤   | 44   | D03        |

### 会社テーブル

| 会社コード | 会社名 |
| ---------- | ------ |
| 1          | A 商事 |
| 2          | B 化学 |

### 部署テーブル

| 部署コード | 会社名 |
| ---------- | ------ |
| D01        | 開発   |
| D02        | 人事   |
| D03        | 営業   |

## 第四正規形

| 社員 ID | チームコード | 製品コード |
| ------- | ------------ | ---------- |
| 000A    | 001          | P1         |
| 000A    | 001          | P2         |
| 000B    | 001          | P1         |
| 000B    | 002          | P1         |
| 001F    | 001          | P2         |
| 001F    | 002          | P2         |
| 003O    | 002          | P2         |
| 003O    | 002          | P3         |

- 上記の「社員-チーム-製品」テーブルには、更新時に問題が発生する。例えば、社員「000A」がチーム「001」から「002」へ移動することになった場合、複数行に対する更新が発生する。またすべての列が主キーの一部を構成するため、NULL を指定することもできない。そのため全列情報が確定するまでレコード登録できない。(所属チームは決まったけど、担当製品が決まっていない社員はどうするか。)
- この場合以下のように第 4 正規化する

| 社員 ID | チームコード |
| ------- | ------------ |
| 000A    | 001          |
| 000B    | 001          |
| 000B    | 002          |
| 001F    | 001          |
| 001F    | 002          |
| 003O    | 002          |

| 社員 ID | 製品コード |
| ------- | ---------- |
| 000A    | P1         |
| 000A    | P2         |
| 000B    | P1         |
| 001F    | P2         |
| 003O    | P2         |
| 003O    | P3         |

## 第 5 正規形

- 第 5 正規形は、先ほどの第 4 正規形、社員-チーム-製品テーブルは「社員 → チーム」、「社員 → 製品」という多値従属性があった。ここにさらに「チーム → 製品」という多値従属性があった場合の正規化ルール。テーブルは以下にする

| 社員 ID | チームコード |
| ------- | ------------ |
| 000A    | 001          |
| 000B    | 001          |
| 000B    | 002          |
| 001F    | 001          |
| 001F    | 002          |
| 003O    | 002          |

| 社員 ID | 製品コード |
| ------- | ---------- |
| 000A    | P1         |
| 000A    | P2         |
| 000B    | P1         |
| 001F    | P2         |
| 003O    | P2         |
| 003O    | P3         |

| チームコード | 製品コード |
| ------------ | ---------- |
| 001          | P1         |
| 001          | P2         |
| 002          | P1         |
| 002          | P2         |
| 002          | P3         |

- 正規化のポイント
  - 更新時の不都合/不整合を排除するために行う
  - 正規化は従属性を見抜くことで可能になる
  - 正規形はいつでも非正規形に戻せる
- 正規化のメリット
  - データの冗長性が排除され、更新時の不整合を防止できる
  - テーブルの持つ意味が明確になり、開発者が理解しやすい
- 正規化のデメリット
  - テーブルの数が増えるため、SQL 文で結合を多用することになりパフォーマンスが悪化する
