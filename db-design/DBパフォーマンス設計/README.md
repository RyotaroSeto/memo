## DB パフォーマンス設計

### インデックス設計

- インデックスの種類
  - B-tree インデックス
  - ビットマップインデックス
  - ハッシュインデックス
- B-tree インデックスが最も有名で通常何もオプションをつけなければ、B-tree インデックスになる
- B-tree は等号(=)検索のみならず,不等号(<,>,<=, <=)や BETWEEN の条件に対しても高速。
  - B-tree は構築される時必ずキー値をソートするため
- B-tree が効果を持たない検索条件は、否定条件(<>,!=)。
  - 特定のノード以外の全てのノードが該当してしまうため
- 親ソート
  - SQL は一切の手続きを記述しないため、select,update の中でも明示的にソートを記述することはない。
  - しかし、以下のような処理を記述した時、暗黙に DBMS 内部でソートが行われる
    - 集約関数(count,sum,avg,max,min)
    - order by 句
    - 集合演算(union,intersect,except)
    - olap 関数(rank,row_number)
  - ソートというのはかなりコストの高い演算。ソートは DBMS 内部で専用メモリ領域が割り当てられており、その内部に一時的にデータを保持して実施されるが、大量データのソートが必要な場合、メモリに乗り切らないためあふれることがある。その場合、DBMS は一時的にディスクへデータを書き出す。この場合の I/O コストが非常に大きくなる。したがって、**SQL 文を記述する際は、極力大きなソートを避けることがパフォーマンス向上**は望ましい
  - B-tree インデックスはキー値をソートして保持しているため、order by 句のキーとして指定した場合、ソート処理をスキップすることが可能、
- B-tree インデックスはどの列に作れば良いか？
  - 大規模なテーブルに対して作成
  - カーディナリティの高い(その列に含まれる異なる値の数が多い)列に作成
    - 目安として特定のキー値を指定した時、全体レコード数の 5%程度に絞り込めるだけのカーディナリティがあること。
      - 例えば 365 日のうち 1 日を指定する select 文を考えるとすれば、0.3%に絞り込めるため「受付日」列に B-tree インデックスを作る意味はある
    - 複合列に対してインデックスを作成する場合、カーディナリティは対象の複合列の組み合わせで考える
    - カーディナリティが高くても、特定の値にデータが集中しているような列は向いていない
  - SQL 文で where 句の選択条件または、結合条件に使用されている列に作成
- データ量が少ない場合、B-tree インデックスを使うより、フルスキャンの方が高速。
- B-tree インデックスと SQL
  - 以下の場合インデックスは利用できない。
    - インデックスを貼った列に演算を行なっている `where col_1 * 1.1 > 100;`
    - インデックスを貼った列に SQL 関数を使っている `SUBSTR(col_1, 1, 1,) = ‘a’`
    - インデックスを貼った列に is null 述語を使っている `col_1 is null;`
    - インデックスを貼った列に否定形を使っている `col_1 <> 100;`
    - インデックスを貼った列に or を用いてる`where col_1 = 99 or col_1 = 100;`
      - or の場合 index が利用できないため、`in`に書き換えて回避する
    - 後方一致、または中間一致の LIKE を使っている
      - `select * from sometable where col_1 like ‘%a’;` NG
      - `select * from sometable where col_1 like ‘%a%’;` NG
      - `select * from sometable where col_1 like ‘a%’;` OK
    - 暗黙の型変換を行なっている
      - `select * from sometable where col_1 = 10;` NG
      - `select * from sometable where col_1 = '10';` OK
      - `select * from sometable where col_1 = CAST(10, AS CHAR(2));` OK
      - データ型の異なる列値を sql において選択条件または結合条件として利用する場合、数値型<=>文字列型、文字列型<=>日付型のように、型変換を行なって型を統一する必要がある。通常 sql 文の中で関数を使って明示的に行うが、明示的に行わなくても、sql 文でエラーにならない。DBMS は内部的に暗黙の型変換を行う。しかしその場合、インデックスは使用されなくなる。
    - 主キーおよび一意制約の列には作成不要。
      - 内部的にインデックスを作成しているため
    - B-tree インデックスは更新性能を劣化させる
      - このトレードオフがあるため極力無駄なインデックスを作成しないようにする
    - 定期的なメンテナンスを行うことが望ましい
- 統計情報収集
  - insert,update,delete などでたくさんのデータが大きく変更された場合、統計情報収集を行うべき。(オプティマイザが正しい道を選べないため)
  - 統計情報取集は長時間かかる処理のため、日中に行わず、システム使用者が少ない夜間に実施すべき
  - 統計情報取集の範囲としては、大きな更新のあったテーブルが対象
  - 統計情報凍結について
    - 現状のものから実行計画を変化させたくない場合、統計情報の更新を止める。
      - 具体的に、システムのサービス終了時のデータを想定した情報での統計情報が存在する場合
- index の再編成を行うコマンド
  - postgres
    - `REINDEX インデックス名`
  - mysql
    - `OPTIMIZE TABLE テーブル名`
- 多くの DBMS には「パーティション」という機能を持っている
  - この機能を用いることで、テーブルを分割することなく、パーティションキー(売上テーブルの場合は年度)を軸として物理的に格納領域を分割できる。
  - 一般的にパーティションはインデックスよりカーディナリティが小さく、値の変更があまり起きない列をキーとして利用する
  - 典型的な例だと「年」や「都道府県」などカーディナリティが十~数十であるキーが対象
  - 「2008」,「2009」,「2010」というように 1 年単位でパーティションを区切れば、SQL 文で特定の 1 年のデータにアクセスする際にも、残りの年度のデータには一切ふれないで I/O を大きく削減できる
  - 基本方針
    - なるべく各パーティションに含まれるレコード数が同じくらいになるキーを選ぶこと。そうでないと、キーによって I/0 量が大きく変わってしまい性能が安定しない
    - SQL 文で選択条件/結合条件に利用されるキーを選ぶこと。せっかくパーティションでデータを区切っても、sql 文で利用されなければ意味がない
    - 値があまり変更されないキーを使うこと。
- データマート(マート)
  - 保持する列を絞ったテーブルを作成するタイプ。指定した列だけを持った新しいテーブルを追加作成する
  - 具体的には下記のようにする
  - オリジナルテーブルを意味的に破壊することなく、パフォーマンス向上させられるので、実際の開発でもよく利用されている
  - デメリットは片方の年齢が更新されたら、もう片方の年齢も更新しなければならない。
  - マートの更新タイミングはタイミングが短いほどオリジナルのテーブルと齟齬がある期間も短くなるので、データ精度が高く機能的には好ましいが、負荷があがる。
  - 多くの場合 1 日 1 回~数回程度の頻度で一括更新(バッチ更新)される。しかしこれは要件と照らし合わせながら期間は慎重に決めるべき。
- サマリテーブル
  - 集約関数によってレコードを集約した状態で保持している。
  - もちろん select 文でアクセスして集約を行なっても良いが、テーブルの規模が大きくなると、その集約処理のコストが大きくなり実行時間が長くなる
  - そのため事前に集約のテーブルを作成しておく。

### 社員テーブル

| 会社コード | 社員 ID | 社員名 | 年齢 | 部署コード |
| ---------- | ------- | ------ | ---- | ---------- |
| C0001      | 000A    | 加藤   | 40   | D01        |
| C0001      | 000B    | 藤本   | 32   | D02        |
| C0001      | 001F    | 三島   | 50   | D03        |
| C0002      | 000A    | 斉藤   | 47   | D03        |
| C0002      | 009F    | 田島   | 25   | D01        |
| C0002      | 010A    | 渋谷   | 33   | D04        |

### 社員(年齢のみ)テーブル

| 会社コード | 社員 ID | 年齢 |
| ---------- | ------- | ---- |
| C0001      | 000A    | 40   |
| C0001      | 000B    | 32   |
| C0001      | 001F    | 50   |
| C0002      | 000A    | 47   |
| C0002      | 009F    | 25   |
| C0002      | 010A    | 33   |

- シャーディング
  - 水平分割。レコードを物理的に分割して格納することで I/0 分散を図るパフォーマンス向上手段。
  - リレーショナル DB のパーティションと違うのは、パーティションによって分割されたテーブルは論理的にはあくまで単一テーブルとして扱うことができるのに対して、シャーディングによって分割されたテーブルは、論理的にも物理的にも異なるテーブルとして扱われる
  - つまりシャーディングはシェアードナッシング型のアーキテクチャを前提としているということ。性能のスケーラビリティが高く、Google のような巨大検索エンジンの DB に使われる
- カラムベースデータベース
  - ほとんどの DB はローベースデータベース。つまり「ロー(行)」を 1 つの物理的な格納単位としている。
  - これに対して、カラムベースの場合、1 つの SQL 文で利用する列が限られている場合、その特定の列だけを読み出すことで、I/O 量を削減でき、パフォーマンス向上につながる。
