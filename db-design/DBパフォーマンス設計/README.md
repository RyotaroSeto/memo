## DB パフォーマンス設計

### インデックス設計

- インデックスの種類
  - B-tree インデックス
  - ビットマップインデックス
  - ハッシュインデックス
- B-tree インデックスが最も有名で通常何もオプションをつけなければ、B-tree インデックスになる
- B-tree は等号(=)検索のみならず,不等号(<,>,<=, <=)や BETWEEN の条件に対しても高速。
  - B-tree は構築される時必ずキー値をソートするため
- B-tree が効果を持たない検索条件は、否定条件(<>,!=)。
  - 特定のノード以外の全てのノードが該当してしまうため
- 親ソート
  - SQL は一切の手続きを記述しないため、select,update の中でも明示的にソートを記述することはない。
  - しかし、以下のような処理を記述した時、暗黙に DBMS 内部でソートが行われる
    - 集約関数(count,sum,avg,max,min)
    - order by 句
    - 集合演算(union,intersect,except)
    - olap 関数(rank,row_number)
  - ソートというのはかなりコストの高い演算。ソートは DBMS 内部で専用メモリ領域が割り当てられており、その内部に一時的にデータを保持して実施されるが、大量データのソートが必要な場合、メモリに乗り切らないためあふれることがある。その場合、DBMS は一時的にディスクへデータを書き出す。この場合の I/O コストが非常に大きくなる。したがって、**SQL 文を記述する際は、極力大きなソートを避けることがパフォーマンス向上**は望ましい
  - B-tree インデックスはキー値をソートして保持しているため、order by 句のキーとして指定した場合、ソート処理をスキップすることが可能、
- B-tree インデックスはどの列に作れば良いか？
  - 大規模なテーブルに対して作成
  - カーディナリティの高い(その列に含まれる異なる値の数が多い)列に作成
    - 目安として特定のキー値を指定した時、全体レコード数の 5%程度に絞り込めるだけのカーディナリティがあること。
      - 例えば 365 日のうち 1 日を指定する select 文を考えるとすれば、0.3%に絞り込めるため「受付日」列に B-tree インデックスを作る意味はある
    - 複合列に対してインデックスを作成する場合、カーディナリティは対象の複合列の組み合わせで考える
    - カーディナリティが高くても、特定の値にデータが集中しているような列は向いていない
  - SQL 文で where 句の選択条件または、結合条件に使用されている列に作成
- データ量が少ない場合、B-tree インデックスを使うより、フルスキャンの方が高速。
- B-tree インデックスと SQL
  - 以下の場合インデックスは利用できない。
    - インデックスを貼った列に演算を行なっている `where col_1 * 1.1 > 100;`
    - インデックスを貼った列に SQL 関数を使っている `SUBSTR(col_1, 1, 1,) = ‘a’`
    - インデックスを貼った列に is null 述語を使っている `col_1 is null;`
    - インデックスを貼った列に否定形を使っている `col_1 <> 100;`
    - インデックスを貼った列に or を用いてる`where col_1 = 99 or col_1 = 100;`
      - or の場合 index が利用できないため、`in`に書き換えて回避する
    - 後方一致、または中間一致の LIKE を使っている
      - `select * from sometable where col_1 like ‘%a’;` NG
      - `select * from sometable where col_1 like ‘%a%’;` NG
      - `select * from sometable where col_1 like ‘a%’;` OK
    - 暗黙の型変換を行なっている
      - `select * from sometable where col_1 = 10;` NG
      - `select * from sometable where col_1 = '10';` OK
      - `select * from sometable where col_1 = CAST(10, AS CHAR(2));` OK
      - データ型の異なる列値を sql において選択条件または結合条件として利用する場合、数値型<=>文字列型、文字列型<=>日付型のように、型変換を行なって型を統一する必要がある。通常 sql 文の中で関数を使って明示的に行うが、明示的に行わなくても、sql 文でエラーにならない。DBMS は内部的に暗黙の型変換を行う。しかしその場合、インデックスは使用されなくなる。
    - 主キーおよび一意制約の列には作成不要。
      - 内部的にインデックスを作成しているため
    - B-tree インデックスは更新性能を劣化させる
      - このトレードオフがあるため極力無駄なインデックスを作成しないようにする
    - 定期的なメンテナンスを行うことが望ましい
- 統計情報収集
  - insert,update,delete などでたくさんのデータが大きく変更された場合、統計情報収集を行うべき。(オプティマイザが正しい道を選べないため)
  - 統計情報取集は長時間かかる処理のため、日中に行わず、システム使用者が少ない夜間に実施すべき
  - 統計情報取集の範囲としては、大きな更新のあったテーブルが対象
  - 統計情報凍結について
    - 現状のものから実行計画を変化させたくない場合、統計情報の更新を止める。
      - 具体的に、システムのサービス終了時のデータを想定した情報での統計情報が存在する場合
- index の再編成を行うコマンド
  - postgres
    - `REINDEX インデックス名`
  - mysql
    - `OPTIMIZE TABLE テーブル名`
