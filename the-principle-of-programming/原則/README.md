# 2. 原則

## KISS
- Keep It Simple, Stupid
- またはKeep It Short and Simple
- シンプルにしておけ、愚か者よ。
- または簡潔かつ単純にしておけ
### コードをシンプルに保つ
- コードを書く場合常に複雑にならないよう意識して、コードをシンプルに保ち続ける

### コードは無秩序へと向かう
- コードは自然に任せて修正していくと、無秩序になり複雑になる
  - 最終的に改善しようとしてもできない腐ったコードになる
- 対してシンプルなコードは各要素が担う責務が最小限に抑えられている。各要素同士の関連もシンプルなため読みやすく、理解しやすく、修正が容易。各要素の責務が明確なためテストもしやすい。
  - コードを通じたプログラマ相互のコミュニケーションが楽になり、現実世界で余計な会話をしなくても済む。
- コードには必ず修正が入るため、修正容易性は欠かせない

### コードに余計なことはしない
- コードから余計なこと、過剰なことを可能な限り排除する。
  - そのためにはプログラミング中「動作させるために、もっともシンプルなものは何か」と常に問いかけるようにすること。精神論だがこれは非常に重要で、意識して作業をしていない限り、複雑へと向かってしまう。例えば以下のようなケースがある
    - 新しく覚えた技術を使いたい
      - ある技術を覚えたての場合、それを使用したいがために不要にトリッキーなコードを書いてしまうことがある。コードは頭の良さをアピールする場でない。ユーザーに価値を提供するものなので、クレバーになってはいけない。そのコードの書き方が本当に必要か吟味しコードがシンプルであり続けることに愚直に取り組む。
    - 将来の必要に備えたい
      - 将来必要になるかもしれないので、そのためには今書くのがベストだと考え、過剰なコードを書いてしまうこともある。しかし、今不要なら、今書くべきではない。ほとんどの場合、それはひつようにならないから。必要になったら必要な分だけ書くようにして、シンプルを保つべき
    - 勝手に要件を加えてしまう
      - 勝手に要件を判断し、余計なコードを加えてしまう場合がある。要件を決めるのはユーザーです。要件にない、余分なコードを書かないことがシンプルに保つ秘訣。

### KISSの適用範囲
- 機能ばかり多くて複雑なソフトウェアは結局使われなくなる。機能、インターフェイスをシンプルに保つと使いやすい、使われるソフトウェアになる。

### less is more
- less is moreはより少ないことはより豊かなことという意味。
- これはソフトウェアにも当てはまり、余分なコードを書かないことによってコードをシンプルに保ち、様々な問題を未然に回避することができる。またそのようにして出来上がったソフトウェアやコードは洗練されて美しいものになる。

### オッカムの剃刀
- オッカムの剃刀とは、ある事柄を説明するために、必要以上に多くの前提を仮定するべきではないという考え方。
  - 別の言い方をすれば、何かについて、いくつかの説明が可能な場合は、最も単純なものが正しいということになる。事柄の理解に対する思考の負荷が減るから。
  - この考え方はプログラミングにおいても有効で、コードが実現している機能が同じなら、余分なものを含まないコードの方が、読み手の負荷が減り、読みやすい改善しやすいコードになる

## DRY
- Dont Repeat Yourself
- 繰り返すな

### コードのコピペ厳禁
- 同じコードを重複して書いてはいけない
  - コードの重複で最も多いのは、ひとまとまりのロジックを安易に別の部分にコピー&ペーストして使用した場合。これにより同じロジックが複数箇所にばらまかれる
- 同じ条件を扱う制御文のブロック群が、様々な場所に重複して現れてしまう場合もある。
  - これもコピー&ペーストの産物で、条件の分岐が同じで、分岐後の処理が異なる場合、一旦コピー&ペーストしてから、処理の部分のみを書き換えている。
- 純粋なコードの重複ではないが、ただ単にコードをそのまま説明しているコメントも重複に当たる。

### コードが改善できなくなる(コードのコピペ厳禁の理由)
- コードの重複があると、障害修正や機能追加などコードを改善していくことが困難になる。具体的には以下
  - コードを読む作業が難しくなる
    - 同じようなコードが複数あると、量的により多くなり、質的により複雑になる。そのため単純にコードを読む作業が難しくなる
  - コードを修正する作業が難しくなる
    - 同じようなコードが複数あると、その複数の箇所を正確に修正しなければ、全体として整合がとれない、慎重に作業しないと修正漏れの危険性もある
  - テストがない
    - 重複しているようなコードは大抵の場合、レガシーコード。その部分のテストがない。
    - 修正してもテストがないと、新たな障害を生んでしまうリスクがかなり高くなる。

### コードを抽象化する(対策)
- コードを抽象化することによって、重複を排除する。
- コードのロジックを抽象化するには、処理のまとまりに名前をつけて、「関数化」「モジュール化」する。データであれば、それに名前をつけて「定数」を定義する
- 抽象化することによって以下のメリットが生まれる
  - コード量が減り、読む量を減らせる
  - ロジックやデータに名前がつくので、コードが読みやすくなる
  - 同じコードが一箇所に集約され、修正箇所が一箇所で済むので、コードが修正しやすくなり、品質担保しやすくなる
  - 抽象化した部分は再利用しやすくなる。新しい機能を追加する際、コードの再利用によって、より早く、より品質良く、プログラミングを完了できる
- ただし抽象化を行うには、メンタル面で乗り越えなければならない壁がある。
  - 例えば、ロジックを関数にするのであれば、それなりに時間がかかる。元の動いていたコードを変えてしまうため、デグレのリスクが発生する。更に率直に面倒。
  - しかし長い目で見ると抽象化した方が有利のため、時間をとってでも重複を排除すべき

### DRYの適用範囲
- DRYの適用範囲は本来コードにとどまらず、ソフトウェア開発に関わる活動全て。
- 具体期には繰り返し作業を「自動化」する。これにより手作業の負担がなくなり、作業が正確になり、人によるバラツキがなくなる
- 自動化対象の代表的な作業は、継続的インテグレーション。
  - ビルド、テスト、デプロイなど
  - ビルドの品質の安定、属人化しないこと、問題の早期発見などメリット

### DRYとプログラミング技術
- プログラミング技術の多くは、DRYを実現するための機能を備えている。
  - というより技術の多くはコードの重複を排除することを目的の1つとしている
  - 例えば、構造化プログラミングやオブジェクト指向プログラミングの技術は関数やモジュールを構成して、重複を排除するための手法を含んでいる
- 設計手法も多くの重複を排除することを目的にしている
  - 代表的な設計手法に、デザインパターンがある。デザインパターンはコードを再利用可能にするための、コード構造パターンを提供している。これは別の側面から見ると、同じような問題について何度も繰り返し解決策を考えるという思考の重複が起きないような手法とも言える
- 手法を学ぶ時はやり方そのものをなぞるだけでなく、その目的を意識することが習得への近道


### やむを得ないDRY違反
- ソフトウェア開発において、ある程度やむを得ない重複も存在する
- 例えば、インピーダンス・ミスマッチ。プログラミングとそれが使用するサービスの溝を埋める情報部分では、不可避な重複が発生する
- この例が、オブジェクト指向プログラミングのクラスと、リレーショナルデータベースのテーブル。
  - リレーショナルデータベースとそれを扱うプログラミング言語があった場合、そのミスマッチを埋めるためには、リレーショナルデータベース側に「テーブル定義」、コード側に「テーブルマッピング設定ファイル」「ソースファイル」と、三箇所に同じ情報を持つことになる。このような重複はある程度仕方ないと言える
  - ただし対策がないわけではない。例えば、情報はどこか1箇所に集中して持たせ、そこから他の情報を自動生成するような仕組みを作れば、情報を一元管理できる


### WET
- DRYに対してWETという概念もある。write every timeないしwrite everything twiceの略語で「同じことを繰り返す」という意味。DRYの対義語
- DRYになっていないコードに対する皮肉的な表現で使用される

### One Fact in One Place
- One Fact in One Placeは「1つの事実は1つの場所のみに存在させる」という意味で、データベース論理設計における、テーブル設計の要となる原則。
- データベースに格納させるデータの重複を禁じ、1つの事実は1つの場所のみに存在させることにより、データの冗長性や不整合を防ぐ。これを防ぐためにデータベースの正規化を行う

### Once and Only Once
- Once and Only Onceは「一度だけ、たった一度だけ」という意味。
- DRYと意味や目的は同じ

### レガシーコード
- テストがないコードをレガシーコードと呼ぶ
- テストのないコードは一律悪いコードとなる。コードが非常に綺麗でしっかり構造化されていてもテストがなければレガシーコード。

## YAGNI
- You Arent Going to Need It
- それはきっと必要にならない

### コードは必要最低限
- コードは多分必要になるだろう、必要になるかもしれないで書いてはいけない。
- 本当に必要になった時、必要なものだけ書くという方針で臨む
- ソフトウェアの変化を完全に予測して、先回りしたコードを書くのは不可能。割り切って今必要なコードのみ書くようにする

### コードの予想は外れる(どうして必要最低限か)
- あらかじめ色々な事態に備えてコードを盛り込んでおいても、結局利用されないことがほとんど
- よかれと思い、予想しながら拡張性を考慮に入れて設計しても、その予想はほぼ外れる
- また、拡張性を考慮に入れると、コードに余計な複雑性を盛り込むことになる。
  - 使われないコードが織り込まれると難解で保守しにくいコードが出来上がることになる
- 使われないものの存在理由はもはや誰にもわからない。

### コードは今必要なものだけ
- 汎用性よりも単純性を考える。
- いくつかの設計案から1つを選択する時、汎用性よりも単純性という価値基準を用いる。
  - 汎用性を誇る複雑な方ではなく、具体的なニーズを基礎とする単純な方を選ぶようにする
  - 単純は解の方が実は汎用性が高かったということはよくある
  - 仮に要件が増えて、機能を拡張することになっても、単純なコードを変更する方が、汎用的に複雑なコードを変更するよりも簡単

### DTSTTCPW
- DTSTTCPWは「Do The Simplest Thing That Could Possibly Work」の略で「うまくいく方法のうち、最もシンプルな方法で行え」という意味
- 意味するところや目的はYAGNIと同じ
- ただし、シンプルを選択することは意外と簡単ではない。明日、来週、来月にプログラミングすることであろうと考えないのは難しい。
- しかし先のことを考えてプログラミングしてしまうと、コードの複雑性が増し。変更のコストが急上昇する
- プログラミングの都度、これらのプリンシプルを思い出し、立ち返る必要がある

## PIE
- Program Intently and Expressively
- 意図を表現してプログラミングせよ。

### コードの意図を伝える
- コードを書くときに大切なことは不特定多数の人に見せるブログやメールを書くのと同じように、意図を明確に表現するように書くということ。
- それはコードが、「コンパイラ」ではなく、「人」が読むためのものであるから。
- したがって、コードにおける表現を工夫して、このソフトウェアはどう動くものなのかをコードの読み手にストレートに伝わるようにコードを書くべき

### コードが唯一の手がかり
- コードだけが、ソフトウェアの動作を正確に完全に知るための手がかり
- ドキュメントが作成されるが、それはソフトウェアがどう動くものなのか明確に知ることはできない
  - 要件定義書はどのようなものが欲しいのかが書いているだけ
  - 基本設計書はどのようなソフトウェアで要件を実現するか書いてあるだけ
  - 詳細設計書はどのような構造でソフトウェアを作るのかの予定が書いてあるだけ
- コードに一番近いが、ダイナミックに変更されるコードとは同期されていない場合が多くなってしまう。そもそも詳細設計書がない場合もありえ、確実に存在し、確実に役立つものではない。
- 結局ソフトウェアの動作を把握するにはコードを読むしかなく、よってわかりやすいコードを書いて、コードの意図を伝えるしかない

### コードは読みやすさが最優先
- コードを書くときは書きやすさより、読みやすさを重視するべき。コードは書かれることより読まれることのが多いから。
- 結果的にコードを書く時間より読む時間の方がはるかに多くなる。たった今自分が書いているコードですら、自分が読んでいる時間の方が多いかもしれない。
- コードは「実行の効率」より「読む効率」が優先される。
  - 読みやすければ、後から実行効率を上げるのは簡単だから。
  - 読む効率が優先なので、コードを書くときには難しい書き方をして自分の頭脳をアピールしないように注意する。技術を覚えたての時、必要もないのにやってしまいがちな、陥りやすい罠。
- コードを読んでいるときに、それが自分のコードでも他人のコードでも、すぐに何を言っているのか理解できない場合は直ちにわかりやすく書き直すようにしましょう。

### モグラ叩き開発を避ける
- 読みやすく、障害のない、品質の高いコードとテストを書くのは、時間がかかる。これは短期的には損失に見えるがモグラ叩きにならないので長期的には必ず利益をもたらす

### コメントは書く
- コメントがなくても読めるような、わかりやすいコードを書くのが理想。
- ただし、コードはどこまで行っても「what」「How」つまり、何をしているか、どのようにやっているかまでしか表現できない。
- 「Why」つまりなぜそれをしているのかを表現するには、コメントを使用する必要がある。
- コメントで説明しなくてもわかりやすいコードを目指しつつ、それでも表現できない部分にはコメントを書く、というバランスを持ったコードを書くようにする

### 文芸的プログラミング
- 文芸的プログラミングは「コードそのものを、ドキュメントにする」という手法。
- 文芸的プログラミングが特に本領を発揮するのは、ソフトウェアの保守段階において。質の高い、量的にも充実した説明情報を直接参照できるので、通常のコードよりも保守作業が格段に容易になる。

## SLAP
- Single Level of Abstraction Principle
- 抽象化レベルの統一

### コードのレベルを合わせる
- コードを書くとき、高いレベルの抽象化概念と低いレベルの抽象化概念を分離するようにする
- その際に、高低2階層ではなく、機能の複雑さに応じて、多階層に分離する。そしてそれらの層において自分の層に所属する抽象レベルを揃える
- つまり、関数を抽象レベルに沿って分割していき、同じ関数に属するコードの抽象レベルを全て統一するということ。
- 抽象レベルが揃うと、結果的に、コードは優れた書籍のようになる。最高水準から中間水準の処理が「書籍の目次」となり、最低水準の処理が「書籍の本文内容」のようになる
  - ※メソッド名が目次で、中身が本文内容

### コードに「要約性」と「閲覧性」をもたせる
- コードがレベルが揃った関数に分割されていると、「要約性」と「閲覧性」を同時に満たすことになる。つまり、関数の一覧は目次のようになり、閲覧性を持つようになる。そして分割された小さなコードの塊になり、閲覧性がよくなる。
- 同じところには同じ抽象どの処理、というようにコードが統一されていると、コードはよどみなく流れ理解しやすくなる。
  - 逆にコードを読んでいて急に抽象度が変わると、コードの流れが途切れる。これまで読んできた部分の理解が飛び、読む人の邪魔になる

### 関数を構造化する
- 処理を意図の伝わりやすい、抽象化レベルが揃った小さなステップ群の関数に変換する
- 関数を構造化すると、各関数は、自身より1段階低いレベルの関数を呼び出す処理の中心となる
  - このような他の関数を呼び出すコードで構成された関数を「複合関数」と呼ぶ
    - 複合関数は極力小さくする。名前で意図を伝えるためであれば、処理が1行であったとしても関数にして構わない
  - また複合関数の中では、様々な抽象レベルの関数を呼ばないようにする。1つの関数の中で、ある部分ではデータベース接続という低水準の処理を行い、他の部分ではビジネスロジックの実行という高水準の処理を行うという書き方をしてはいけない。

### SLAPの適用範囲
- SLAPは関数に限らず、モジュールなどにも適用される


### SLAPの手順
- SLAP化の作業は文章を書く時の手順が参考になる
  - 優れた文章を書く肝は「内容を書くこと」と「内容をわかりやすく伝えるための構成を考えること」を別の作業にすること
  - この作業の分断がコードを書く場合にも当てはまる。
    - つまり具体的な処理を書く作業と抽象化レベルを揃える作業はモードを切り替え、別の作業として行うようにする。その方が作業がやりやすく、結果的によりよいコードになる

