# 2. 原則

## KISS
- Keep It Simple, Stupid
- またはKeep It Short and Simple
- シンプルにしておけ、愚か者よ。
- または簡潔かつ単純にしておけ
### コードをシンプルに保つ
- コードを書く場合常に複雑にならないよう意識して、コードをシンプルに保ち続ける

### コードは無秩序へと向かう
- コードは自然に任せて修正していくと、無秩序になり複雑になる
  - 最終的に改善しようとしてもできない腐ったコードになる
- 対してシンプルなコードは各要素が担う責務が最小限に抑えられている。各要素同士の関連もシンプルなため読みやすく、理解しやすく、修正が容易。各要素の責務が明確なためテストもしやすい。
  - コードを通じたプログラマ相互のコミュニケーションが楽になり、現実世界で余計な会話をしなくても済む。
- コードには必ず修正が入るため、修正容易性は欠かせない

### コードに余計なことはしない
- コードから余計なこと、過剰なことを可能な限り排除する。
  - そのためにはプログラミング中「動作させるために、もっともシンプルなものは何か」と常に問いかけるようにすること。精神論だがこれは非常に重要で、意識して作業をしていない限り、複雑へと向かってしまう。例えば以下のようなケースがある
    - 新しく覚えた技術を使いたい
      - ある技術を覚えたての場合、それを使用したいがために不要にトリッキーなコードを書いてしまうことがある。コードは頭の良さをアピールする場でない。ユーザーに価値を提供するものなので、クレバーになってはいけない。そのコードの書き方が本当に必要か吟味しコードがシンプルであり続けることに愚直に取り組む。
    - 将来の必要に備えたい
      - 将来必要になるかもしれないので、そのためには今書くのがベストだと考え、過剰なコードを書いてしまうこともある。しかし、今不要なら、今書くべきではない。ほとんどの場合、それはひつようにならないから。必要になったら必要な分だけ書くようにして、シンプルを保つべき
    - 勝手に要件を加えてしまう
      - 勝手に要件を判断し、余計なコードを加えてしまう場合がある。要件を決めるのはユーザーです。要件にない、余分なコードを書かないことがシンプルに保つ秘訣。

### KISSの適用範囲
- 機能ばかり多くて複雑なソフトウェアは結局使われなくなる。機能、インターフェイスをシンプルに保つと使いやすい、使われるソフトウェアになる。

### less is more
- less is moreはより少ないことはより豊かなことという意味。
- これはソフトウェアにも当てはまり、余分なコードを書かないことによってコードをシンプルに保ち、様々な問題を未然に回避することができる。またそのようにして出来上がったソフトウェアやコードは洗練されて美しいものになる。

### オッカムの剃刀
- オッカムの剃刀とは、ある事柄を説明するために、必要以上に多くの前提を仮定するべきではないという考え方。
  - 別の言い方をすれば、何かについて、いくつかの説明が可能な場合は、最も単純なものが正しいということになる。事柄の理解に対する思考の負荷が減るから。
  - この考え方はプログラミングにおいても有効で、コードが実現している機能が同じなら、余分なものを含まないコードの方が、読み手の負荷が減り、読みやすい改善しやすいコードになる

## DRY
- Dont Repeat Yourself
- 繰り返すな

### コードのコピペ厳禁
- 同じコードを重複して書いてはいけない
  - コードの重複で最も多いのは、ひとまとまりのロジックを安易に別の部分にコピー&ペーストして使用した場合。これにより同じロジックが複数箇所にばらまかれる
- 同じ条件を扱う制御文のブロック群が、様々な場所に重複して現れてしまう場合もある。
  - これもコピー&ペーストの産物で、条件の分岐が同じで、分岐後の処理が異なる場合、一旦コピー&ペーストしてから、処理の部分のみを書き換えている。
- 純粋なコードの重複ではないが、ただ単にコードをそのまま説明しているコメントも重複に当たる。

### コードが改善できなくなる(コードのコピペ厳禁の理由)
- コードの重複があると、障害修正や機能追加などコードを改善していくことが困難になる。具体的には以下
  - コードを読む作業が難しくなる
    - 同じようなコードが複数あると、量的により多くなり、質的により複雑になる。そのため単純にコードを読む作業が難しくなる
  - コードを修正する作業が難しくなる
    - 同じようなコードが複数あると、その複数の箇所を正確に修正しなければ、全体として整合がとれない、慎重に作業しないと修正漏れの危険性もある
  - テストがない
    - 重複しているようなコードは大抵の場合、レガシーコード。その部分のテストがない。
    - 修正してもテストがないと、新たな障害を生んでしまうリスクがかなり高くなる。

### コードを抽象化する(対策)
- コードを抽象化することによって、重複を排除する。
- コードのロジックを抽象化するには、処理のまとまりに名前をつけて、「関数化」「モジュール化」する。データであれば、それに名前をつけて「定数」を定義する
- 抽象化することによって以下のメリットが生まれる
  - コード量が減り、読む量を減らせる
  - ロジックやデータに名前がつくので、コードが読みやすくなる
  - 同じコードが一箇所に集約され、修正箇所が一箇所で済むので、コードが修正しやすくなり、品質担保しやすくなる
  - 抽象化した部分は再利用しやすくなる。新しい機能を追加する際、コードの再利用によって、より早く、より品質良く、プログラミングを完了できる
- ただし抽象化を行うには、メンタル面で乗り越えなければならない壁がある。
  - 例えば、ロジックを関数にするのであれば、それなりに時間がかかる。元の動いていたコードを変えてしまうため、デグレのリスクが発生する。更に率直に面倒。
  - しかし長い目で見ると抽象化した方が有利のため、時間をとってでも重複を排除すべき

### DRYの適用範囲
- DRYの適用範囲は本来コードにとどまらず、ソフトウェア開発に関わる活動全て。
- 具体期には繰り返し作業を「自動化」する。これにより手作業の負担がなくなり、作業が正確になり、人によるバラツキがなくなる
- 自動化対象の代表的な作業は、継続的インテグレーション。
  - ビルド、テスト、デプロイなど
  - ビルドの品質の安定、属人化しないこと、問題の早期発見などメリット

### DRYとプログラミング技術
- プログラミング技術の多くは、DRYを実現するための機能を備えている。
  - というより技術の多くはコードの重複を排除することを目的の1つとしている
  - 例えば、構造化プログラミングやオブジェクト指向プログラミングの技術は関数やモジュールを構成して、重複を排除するための手法を含んでいる
- 設計手法も多くの重複を排除することを目的にしている
  - 代表的な設計手法に、デザインパターンがある。デザインパターンはコードを再利用可能にするための、コード構造パターンを提供している。これは別の側面から見ると、同じような問題について何度も繰り返し解決策を考えるという思考の重複が起きないような手法とも言える
- 手法を学ぶ時はやり方そのものをなぞるだけでなく、その目的を意識することが習得への近道


### やむを得ないDRY違反
- ソフトウェア開発において、ある程度やむを得ない重複も存在する
- 例えば、インピーダンス・ミスマッチ。プログラミングとそれが使用するサービスの溝を埋める情報部分では、不可避な重複が発生する
- この例が、オブジェクト指向プログラミングのクラスと、リレーショナルデータベースのテーブル。
  - リレーショナルデータベースとそれを扱うプログラミング言語があった場合、そのミスマッチを埋めるためには、リレーショナルデータベース側に「テーブル定義」、コード側に「テーブルマッピング設定ファイル」「ソースファイル」と、三箇所に同じ情報を持つことになる。このような重複はある程度仕方ないと言える
  - ただし対策がないわけではない。例えば、情報はどこか1箇所に集中して持たせ、そこから他の情報を自動生成するような仕組みを作れば、情報を一元管理できる


### WET
- DRYに対してWETという概念もある。write every timeないしwrite everything twiceの略語で「同じことを繰り返す」という意味。DRYの対義語
- DRYになっていないコードに対する皮肉的な表現で使用される

### One Fact in One Place
- One Fact in One Placeは「1つの事実は1つの場所のみに存在させる」という意味で、データベース論理設計における、テーブル設計の要となる原則。
- データベースに格納させるデータの重複を禁じ、1つの事実は1つの場所のみに存在させることにより、データの冗長性や不整合を防ぐ。これを防ぐためにデータベースの正規化を行う

### Once and Only Once
- Once and Only Onceは「一度だけ、たった一度だけ」という意味。
- DRYと意味や目的は同じ

### レガシーコード
- テストがないコードをレガシーコードと呼ぶ
- テストのないコードは一律悪いコードとなる。コードが非常に綺麗でしっかり構造化されていてもテストがなければレガシーコード。
