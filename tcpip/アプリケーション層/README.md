### HTTP

- HTTP0.9
    - HTMLで記述されたテキストフィルをサーバーからダウンロードするだけ
- HTTP1.0
    - テキストファイル以外にも動画ファイルや画像ファイルなど色々扱えるようになり、ダウンロードだけでなくアップロードや削除もできるようになった
    - TCPコネクションをオープンにし、コンテンツダウンロードが終わったらクローズするという手順を4回繰り返すため負荷になりやすい処理
    - ちなみにWebブラウザは一つのサーバーに対して同時にオープンできるTCPコネクション数(最大接続数)が決められていて、デフォルトは6
- HTTP1.1
    - keepalive(持続的接続)やパイプラインなどパフォーマンス向上を図る機能が盛り込まれた
    - keepalive(持続的接続)
        - 一度作ったTCPコネクションを使い回す機能
        - 最初にTCPコネクションを作っておいてその上で複数のHTTPリクエストを送信する。新規コネクション数が減り、システム全体の処理負荷が大きく期限する。
        - TCPハンドシェイク分のパケットの往復時間が少なくなるためスループットが向上する
    - パイプライン
        - リクエストに対するレスポンスを待たずに、次のリクエストを送信する機能
        - しかし、現実にはパイプラインは期待通りの成果はあげることができなかった。理由としてHTTP1.1は同じTCPコネクション内でリクエストとレスポンスのやりとりを並列処理できない仕様になっているから。(待ちが発生してしまう)
- HTTP2.0
    - これまでテキスト形式のメッセージ単位でやりとりしていたアプリデータを、「フレーム」と呼ばれるバイナリ形式の単位でやりとりすることによって、オーバーヘッドを削減し、パフォーマンス向上を図っている。
    - マルチプレキシング・HPACK・サーバープッシュなど、TCPレベルだけでなく、アプリケーションレベルにおいてもパフォーマンス向上を図る機能が盛り込まれた
    - マルチプレキシング
        - HTTP1.1のパイプラインはHoLブロッキング問題があったため使用されなかった。その反省も踏まえ、パイプラインの代わりに追加された機能
        - 1本のTCPコネクションの中にストリームという名前の仮想チャネルを作り、ストリームごとにリクエストとレスポンスをやり取りすることによって、HoLブロッキング問題を解消する
    - HPACK
        - メッセージヘッダー(HTTPヘッダー)を圧縮する機能。メッセージヘッダーはHTTPに関する制御機能を格納するフィールド。HTTP1.1は同じ内容のヘッダーをなん度もやりとりするため、無駄の多いプロトコルだった。圧縮機能はあったものの、メッセージボディのみでメッセージヘッダーは対象外だった
        - よく使用するHTTPヘッダー名やヘッダー値をあらかじめ静的にきめられた数字におきかえたり、一度送信したHTTPヘッダーを動的に割り当てた数字に置き換えることによってヘッダーの転送量を削減する
    - サーバープッシュ
        - HTTP1.1はHTTPは1つのリクエストに対して1つのレスポンスを返す。プル型のプトロコ流
        - HTTP2は一つのリクエストに対して複数のレスポンスを返す、プッシュ型の機能を追加している。これがサーバープッシュ。
        - HTTP2サーバーはクライアントが最初にリクエストしたコンテンツを解析し、次にくるであろうリクエストに対するレスポンスをリクエストが来る前に解析する
            - 例えばindex.htmlがscript.jsとstyle.cssを読み込むHTMLだった場合、index.htmlに対するリクエストの後にscript.jsとstyle.cssに対するリクエストが来ることが予想される。そこでHTTP2サーバーはそのリクエストが来る前に、script.jsとstyle.cssをレスポンスしておく。webブラウザはそのレスポンスをキャッシュし、script.jsとstyle.cssのリクエストに対するレスポンスをキャッシュ領域から呼び出す
- HTTP3.0
    - HTTP2.0のパワーアップ。アプリケーションデータを送れない時間を徹底的に削ることで更なるパフォーマンス向上を図る
    - UDPによる遅延削減
        - HTTP3で最も劇的に変化したことはTCPでなく、UDPを使用していること。TCPの3ハンドシェイクにかかる時間を削減し、よりたくさんのHTTPデータを送れるようにしている
    - TLS1.3による遅延削減
        - HTTP3はセキュリティ事情を考慮して、TLS1.3というプロトコルによる暗号化通信を前提としている
        - TLSは暗号化通信するためにSSLハンドシェイクを行う。SSLハンドシェイクはセキュリティを確保するために必要な処理。しかし3ウェイハンドシェイクと同じく、その間アプリケーションデータをやり取りできないため、遅延の原因なる。TLS1.3はより少ないパケットのやり取りで素早く認証・暗号化できるように、SSLハンドシェイクの効率化が図られている。
        - すでにYoutubeなどはHTTP3を使用している
- HTTP1.1のメッセージフォーマット
    - HTTPメッセージの中に以下が入っている
        - スタートライン
            - メッセージの種類を表す
        - メッセージヘッダー
            - HTTPの制御情報が複数行にわたって記述されている
        - 空行(\r\n)
            - メッセージボディとメッセージヘッダーの境界線
        - メッセージボディ
            - アプリケーションの本文(HTTPペイロード)
    - リクエストメッセージのフォーマット
        - リクエストライン
            - クライアントがサーバーに処理をお願いするための行
            - メソッド、リクエストURI、HTTPバージョンの3つで構成されている
        - レスポンスメッセージのフォーマット
            - ステータスライン
                - WebサーバーがWebブラウザに対して処理結果の概要を返す行
                - HTTPバージョン、ステータスコード、リーズンフレーズ(OK,NotFoundなど)で構成されている
- 色々なHTTPヘッダー
    - リクエストヘッダー
        - リクエストを制御するためのヘッダー
        - Accept,Authrization,Host,Range,User-Agentなど色々
        - Acceptヘッダー
            - Webブラウザでが処理できるファイルの種類とその相対的な優先度をWebサーバーに伝えるために使用するリクエストヘッダー。このファイルタイプだったら処理できますと送る
            - Acceptヘッダーに使用するMIMEタイプはHTML形式のテキストファイルだったらtext/html、PNG形式の画像ファイルだったらimage/pngのように「タイプ/サブタイプ」のフォーマットで表記する。また「*」は全てを表す
            - ちなみに複数のMIMEタイプを指定している場合「,」でつなげる
            - 複数のMIMEタイプを処理できて、それに優先度をつけたい場合、qvalue(品質係数)をしようする
        - HOSTヘッダー
            - Webサーバーのドメイン名とポート番号がセットされる
            - ひとつのIPアドレスで複数のドメインを運用する「Virtual Host」という機能をしようしている時力を発揮する。Virtual Hostを有効にしているWebサーバーはHostヘッダーにセットされているFQDNを見て、対象となるVirtual Hostにリクエストを振り分け、それに応じたコンテンツをレスポンスする
        - Refererヘッダー
            - 直前のリンク元のURIを示すヘッダー
            - 自分が運用しているWebサイトへのアクセスがどこから来ているのか、これはセールスプロモーションを打つ上でとても重要な情報。Webサイト管理者はRefererヘッダーの情報をWebサーバーのアクセスログに記録・分析し、マーケティング部に展開する
        - User-Agentヘッダー
            - WebブラウザやOSなど、ユーザー環境を表すヘッダー。これもアクセス解析で使用
    - レスポンスヘッダー
        - レスポンスメッセージを制御するためのヘッダー
        - Etagヘッダー
            - Webサーバーの持つファイルなどのリソースを一意に識別するためのヘッダー
        - Locationヘッダー
            - リダイレクト先を通知するために使用するヘッダー
            - リダイレクトを表す300番台のステータスコードと合わせて使用する
            - Locationヘッダーにはリダイレクト先のURIがセットされる
        - Serverヘッダー
            - Webサーバーの情報がセットされるヘッダー
            - OSやそのバージョン、ソフトウェアやそのバージョンなどがセットされる
            - 基本はWebサーバーの設定でServerヘッダーを無効化しておく。Apacheの場合、「mod_headers」で無効化できる
    - 一般ヘッダー
        - Cache-Controlヘッダー
            - Webブラウザやサーバーのキャッシュを制御するために使用。
            - プライベートキャッシュと共有キャッシュの2種類ある
            - プライベートキャッシュは主にwebブラウザに保持されるキャッシュ。
            - 共有キャッシュはプロキシサーバーやCDNのエッジサーバーに保持されるキャッシュ
            - 「ディレクティブ」というコマンドをフィールド値に格納することによって、キャッシュの可否や有効期限、キャッシュされる場所などを制御する
            - リクエストディレクティブ
                - no-cache
                    - キャッシュを使用しない
                - no-store
                    - プライベートキャッシュ、共有キャッシュにかかわらずキャッシュさせない
                - max-age=[秒]
                    - キャッシュの有効期間を指定する
                - レスポンスディレクティブ
                - public
                    - 共有キャッシュにキャッシュさせる
                - private
                    - 共有キャッシュにキャッシュさせない
                - no-cache
                    - 有効性を確認しないとキャッシュを使用させない
                - no-store
                    - プライベートキャッシュ、共有キャッシュにかかわらずキャッシュさせない
                - must-revalidate
                    - キャッシュの有効期限が切れている場合、有効性を確認しないとキャッシュさせない
                - max-age=[秒]
                    - キャッシュの有効期間を指定する
                - s-max-age=[秒]
                    - 共有キャッシュにおいてmax-ageよりも優先される有効期間を指定する
                - immutable
                    - 有効性を確認せずにキャッシュを使用させる
        - Connecttionヘッダー/Keep-Aliveヘッダー
            - どちらもキープアライブを制御するヘッダー
            - Connectionヘッダーにkeep-aliveをセットして、キープアライブに対応しているよとサーバーに伝える。
            - KeepAliveヘッダーを使用して次のリクエストが来ないようにタイムアウトする時間やTCPコネクションにおける残りのリクエスト数などを伝える。
            - ConnectionヘッダーにcloseなどセットされていたらTCPコネクションを閉じる
        - エンティティヘッダー
            - Content-Encodingヘッダー/Accept-Encodingヘッダー
                - Webブラウザがしょりできるメッセージボディの圧縮方式を指定するヘッダー
            - Content-Lengthヘッダー
                - HTTP1.1はキープアライブによって一つのコネクションを使い回すことがあるため、必ずしもTCPコネクションがクローズされるとは限らない
                - そこでContent-Lengthヘッダーを使用して、メッセージの境界をTCPに伝え、適切にTCPコネクションがクローズされるようにする
        - その他ヘッダー
            - Set-Cookie/Cookie
                - HTTPサーバーとの通信で特定の情報をブラウザに保持させる仕組み、または保持したファイルのこと
            - X-Forwarder-For
                - 負荷分散装置で送信元IPアドレスが変換されるような環境において、変換前の送信元IPアドレスを格納するヘッダー
                - NAPTしないと負荷分散処理できないことがある。しかしNAPTしてしまうと、どのクライアントからアクセスされたかわからなくなる。そこでX-Forwarder-Forを使用すると、どのIPアドレスからアクセスされたか特定することができる
                - AWSの負荷分散機能であるELBやALBも送信元IPアドレスがELB/ALBのIPアドレスに変換される、従って単純に送信元IPアドレスだけ見ても、どのIPアドレスからアクセスされたかわからない。X-Forwarder-Forの値を見るとどのIPアドレスからアクセウsされているか特定できる
            - X-Forwarder-Proto
                - X-Forwarder-Forのプロトコル版
- HTTP2のメッセージフォーマット
    - メッセージヘッダーを「HEADERSフレーム」に、メッセージボディを「DATAフレーム」にそれぞれ分割して格納し、バイナリ形式のフレーム単位でストリームに流す。その際にフレ０無にストリームを識別する「ストリームID」を付与し、どのストリームにフレームを流すかを指定する。バイナリ形式のままなので変換処理は必要ない
        - http1.1はバイナリ形式を一度テキスト形式にして送信して、受け取り側もテキスト形式をバイナリ形式に直している。http2はその変換処理をしていない分速い
    - リクエストラインとステータスライン
        - http2はリクエストラインとステータスラインの構成要素をヘッダーとして扱う
        - リクエストライン
            - http1.1のリクエストラインは、リクエストの種類の「メソッド」、リソースの識別子の「リクエストURI」、httpバージョンの1行のテキストにして送信。
            - http2はメソッドを「:methodヘッダー」、リクエストURIを「:pathヘッダー」というヘッダーの一つとして扱い、他のヘッダーとともにHEADRSフレームに格納する。バージョンは廃止された
        - ステータスライン
            - http1.1のステータスラインはhttpバージョン、処理結果の概要を数字で表す「ステータスコード」その理由を表す「リーズンフレーズ」を1行のテクストとして送信
            - http2のステータスコードは「:statusヘッダー」というヘッダーの一つとして扱い、他のヘッダーとともにHEADERSフレームに格納。バージョンとリーズンフレーズは廃止された
    - プロトコルアップグレード
        - SSLハンドシェイクパターン
            - SSLハンドシェイクとはSSL/TLSで暗号化通信する前に行う事前準備
            - 暗号化方式や認証方式を決めたり、お互い認証したり、暗号化に使用する共通鍵を交換したりする、
            - HTTP2で接続する時は、SSLハンドシェイクのALPNという拡張機能を使う
            - ALPNを使用して、お互いがhttp2に対応していることを伝え合い接続する
        - httpヘッダーパターン
            - SSL/TLSで暗号化しない場合、ALPNを使えないのでHTTPヘッダーを使う
            - http2に対応していたらupgradeヘッダーをつけて101のステータスコードを返すhttp2に移行、http2に対応していなかったら1.1に接続する
        - ダイレクト接続パターン
            - あらかじめhttp2に対応しているとわかっていたらいきないhttp2に接続する
- 負荷分散装置の動作
    - 負荷分散装置はネットワーク層(IPアドレス)やトランスポート層(ポート番号)、アプリケーション層(メッセージ)の情報を利用して、複数のサーバーにコネクションを割り当てる機器
    - 宛先NAT
        - サーバー負荷分散技術の基本は宛先NAT。
        - 負荷分散装置はクライアントからパケットを受け取ると、サーバーの生死状態やコネクション状態を確認し、最適なサーバーのIPアドレスに宛先IPアドレスを変換する
    - ヘルスチェック
        - 負荷分散対象のサーバーの状態を監視する機能。定期的にパケットを送って稼働監視しダウンしていたら、そのサーバーを負荷分散体操から切り離す
        - ヘルスチェックは「L3チェック」「L4チェック」「L7チェック」の3種類に大別できる
        - サーバーのリソースにゆとりがあれば「L3+L7チェック」ゆとりがなければ「L3+L4チェック」を選択する
    - 負荷分散方式
        - どの情報を使って、どのサーバーに割り振るか。宛先NATで書き換えられる宛先IPアドレスが変わる
        - 大きく静的と動的に分けられる
        - 静的な負荷分散方式はサーバーの状況は関係なしに定義された設定にも続いてサーバーを決める。順番に割り振る「ラウンドロビン」やあらかじめ決めた比率に基づいて割り振る「比率」などがある
        - 動的な負荷分散方式はサーバーの状況に応じて割り振るサーバーを決める。コネクション数に応じて割り振る「最小コネクション数」や応答時間に応じて割り振る「最短応答時間」などある
    - オプション機能
        - 負荷分散装置はその活躍の場をアプリケーション層まで広げ、アプリケーションデリバリーコントローラーとよばれるようになった
        - パーシステンス
            - アプリケーションの同じセッションを同じサーバーに割り振る続ける機能
        - アプリケーションスイッチング
            - 負荷分散装置機能に加え、リクエストURIやWebブラウザの種類などアプリケーションデータにふくまれる色々な情報をもとにより決め細かく、かつ幅広い負荷分散を行う
        - HTTP2オフロード
            - オフロードはサーバーの行う処理を肩代わりする機能。HTTP2オフロードはHTTP2の処理を肩代わりする
            - HTTP２オフロードを使用すれば、サーバーはhttp1.1のままシステムをhttp2に対応することができ、実装までの時間を節約できる

### SSL/TLS

- アプリケーションデータを暗号化、通信相手を認証したりするプロトコル。
- httpsになっていて、アドレスバーに錠前マークになっているのがSSLで暗号化されていてデータが守られていることを占める。
- SSLで使用している技術
    - SSLで防ぐことができる脅威
        - SSLは「暗号化」「ハッシュ化」「デジタル証明書」という3つの技術を組み合わせて使用している
        - 暗号化で盗聴を防ぐ
            - 暗号化は決められたルールに基づいてデータを変換する技術。
        - ハッシュ化で改ざんを防ぐ
            - ハッシュ化はアプリケーションデータから決められた計算(ハッシュ関数)に基づいて固定長のデータを取り出す技術
            - SSLはデータ改ざんされていないか確認するためにデータとハッシュ値をあわせて送信する。それを受け取った端末はデータから計算して得たハッシュ値と添付されているハッシュ値を比較する。同じデータに対して同じ計算をするため同じハッシュ値ならデータ改ざんされていないことになる
        - デジタル証明書でなりすましを防ぐ
            - デジタル証明書はその端末が本物であるかを証明するファイル。
            - SSLではデータを送信するのに先立って「あなたの情報ください」とお願いして、送られてきたデジタル証明書をもとに正しい相手か判断する
            - デジタル証明書が本物かどうかは「認証局」とよばれる信頼できる第三者機関の「デジタル署名」によって判断する。
    - SSLで使用する暗号化方式
        - データを暗号化するための「暗号化鍵」と暗号化を解く「複合鍵」が必要
        - ネットワークにおける暗号化方式は「共通鍵暗号化方式」と「公開鍵暗号化方式」の2種類に大別できる
        - 共通鍵暗号化方式
            - 暗号化鍵と複号鍵に同じ鍵(共通鍵)を使用する暗号化方式。クラウアントとサーバーはあらかじめ同じ鍵を共有していて、暗号化鍵で暗号化し、暗号化鍵と全く同じ鍵で複合する
            - 共通鍵暗号化方式はさらに「ストリーム暗号」と「ブロック暗号」に大別できる
            - ストリーム暗号
                - 1ビット、あるいは1バイトごとに暗号化処理を行う暗号化方式。脆弱性が見つかり現在使用されていない
            - ブロック暗号
                - データを一定のビット数に区切って1つ一つ暗号化処理を施す
                - ストリーム暗号と比較して処理に少し時間がかかるものの脆弱性が報告されておらず、今でも使用されている
            - 共通鍵暗号化方式のメリットは、処理速度と処理負荷。高速で負荷もかからない
            - 共通鍵暗号化方式のデメリットは、鍵配送問題。あらかじめ同じ鍵を共有する。の渡し方をどうするのかを別の仕組みで解決しなければならない
        - 公開鍵暗号化方式
            - 暗号化鍵と複号鍵に異なる鍵を使用する暗号化方式
            - 公開鍵と秘密鍵を使用している.以下は暗号化の流れ
                - 1. webサーバーは公開鍵と秘密鍵を作る
                - 2. webサーバーは公開鍵をみんなに公開・配布し秘密鍵だけを保管する
                - 3. webブラウザは公開鍵を暗号化鍵として使用し、データを暗号化して送信
                - 4. webサーバーは秘密鍵を復号鍵として使用しデータを復号する
            - 公開鍵暗号化方式のメリットは、鍵を配送する必要がないこと
            - デメリットは処理速度と処理負荷
        - ハイブリッド暗号化方式
            - 共通鍵暗号化方式と公開鍵暗号化方式のメリットデメリットいいとこどり。
            - 以下が処理の流れ
                - 1. webサーバーは公開鍵と秘密鍵を作る
                - 2. webサーバーは公開鍵をみんなに公開・配布し秘密鍵だけを保管する
                - 3. webブラウザは共通鍵をもとに公開鍵で暗号化して送信
                - 4. webサーバーは共通鍵の元を秘密鍵で復号する
                - 5. webサーバーとwebブラウザは共通鍵の元から共通鍵を生成
                - 6. webブラウザはアプリケーションデータを共通鍵で暗号化
                - 7. webサーバーはアプリケーションデータを共通鍵で復号する
    - SSLで使用するハッシュ関数
        - ハッシュ化はアプリケーションデータをハッシュドポテトのように細切れにして同じサイズのデータをまとめる技術
        - ハッシュ値を比較した方が効率的
            - データとデータが全く同じものか、改ざんされていないか確認したい時、データとデータの比較もできるが、データ量が多い時は時間がかかるのでハッシュ化して比較した方が効率的である
            - ハッシュ値から元データには戻せない
            - データサイズが異なっても、ハッシュ値のサイズは固定
            - SSLではこのハッシュ化をアプリケーションデータの検証とデジタル証明書の検証に使用している
                - アプリケーションデータの検証はハッシュ関数だけでなく、それを発展させたメッセージ認証コードという技術を使用している。メッセージ認証コード(sha-256)はアプリケーションデータとMAC鍵(共通鍵)をまぜこぜしてMAC値(ハッシュ値)を計算する技術。一方こうハッシュ関数に共通鍵の要素が加わるため、改ざん検知だけでなく、相手を認証することもできる
                - デジタル署名は、署名前証明書をデジタル署名のアルゴリズムで指定されたハッシュ関数でハッシュ化し、認証局の秘密鍵で暗号化したもの。デジタル証明書を受け取った受信者はデジタル署名を認証局の公開鍵で復号し、署名前証明書のハッシュ値と比較、検証する
- SSLのレコードフォーマット
    - SSLによって運ばれるメッセージをSSLレコードという。SSLレコードはSSLの制御情報を扱うSSLヘッダーとその後に続くSSLペイロードで構成されている。SSLヘッダーはコンテンツタイプ、プロトコルバージョン、SSLペイロード長の3つのフィールドで構成されている
- SSLの接続から切断までの流れ
    - サーバー証明書を用意
    - SSLハンドシェイクで事前準備
    - 暗号化通信
    - SSLセッション再利用
    - SSLセッションのクローズ
- クラウアント証明書でクライアントを認証する
    - クラウアント証明はあらかじめWebブラウザにインストールしておいてクラウアント証明書を利用して、クライアントを認証する
- SSLオフロード機能の動作
    - SSLオフロードは負荷分散装置のオプションの1つで、これまでサーバーで行っていたSSLの処理を負荷分散装置で行う処理

### DNS

- DNSはIPアドレスとドメイン名を相互に変換するプロトコル
- DNSはIPアドレスにドメイン名という名前をつけて、人間にとってわかりやすい形で通信をおこなえるようにする
- 実際にWebブラウザでGoogleのWebサイトにアクセスするときは、まずWebブラウザがDNSサーバーに対して、www.google.comに割り当てられているIPアドレスを問い合わせ、回答されたIPアドレスに対してHTTPSでアクセスしている
- DNSサーバーの冗長化とゾーン転送
    - キャッシュサーバーの冗長化
        - キャッシュサーバーはDNSクライアントが問い合わせた名前解決の情報をキャッシュかしている。よってプライマリDNSサーバーとセカンダリDNSサーバーとのあいだで何か情報を同期する必要はなく、サーバーの機能で冗長化する必要はない
        - DNSクライアント側の設定でプライマリDNSサーバーとセカンダリDNSサーバーを指定しておく。プライマリDNSサーバーからリプライが返ってこなかったら、セカンダリDNSサーバーに再帰クエリする
    - 権威サーバーの冗長化
        - 権威サーバーは自身が管理するドメインに関する情報(ゾーンファイル)を保持している重要なサーバー
        - 同じゾーンファイルを保持するために、DNSサーバー間でゾーンファイルを同期する処理のことをゾーン転送という。プライマリDNSサーバーのゾーンファイルのコピーをセカンダリDNSサーバーに転送する
- DNSを利用した機能
    - DNSラウンドロビン
        - 一つのドメイン名に複数のIPアドレスを登録しておくと、DNSクエリを受け取るたびに順番に異なるIPアドレスを返す、これにより、クライアントは同じドメイン名で異なるサーバーに接続することになり、サーバーの負荷が分散される
    - 広域負荷分散
        - 地理的に離れた場所にあるサーバーに通信を振り分け負荷分散する技術
        - 広域負荷分散は負荷分散としての目的より、災害が発生したときに別サイトでサービスを提供し続ける災害対策の目的として使用されている
    - CDN
        - webコンテンツを大量配信するために最適化されたインターネット上のサーバーネットワーク
### メール系プロトコル

- メールは送信と受信に別々のプロトコルを使用している
- メール送信プロトコル
    - メール送信にはSMTPを使用している
    - SMTP
        - TCPの25番を使用して通信を行う
        - メールを送信するときのが流れ(イメージとして郵便配達)
            - メールサーバーはメールソフトからメールを受け取ると、宛先メールアドレスのアットマークより後ろに記述されているFQDNを見て、DNSサーバーにMXレコードを問い合わせる
            - DNSサーバーによって相手のメールサーバーのIPアドレスがわかったらそのIPアドレスに対してメール送信する
            - メールを受け取った宛先側のメールサーバーは宛先メールアドレスのアットマークより前に記述されているユーザー名を見て、ユーザーごとに用意されているストレージ領域「メールボックス」にメールを振り分け格納する
        - 認証機能
            - SMTP認証(現在利用されている)
                - TCPの587番を使用する。
                - メールサーバーはメールを送信する前にユーザー名とパスワードでユーザーをチェックする。成功したらメールを受け入れる
            - POP before SMTP
                - POPを利用したユーザー認証機能
                - popはメールを受信する前に、ユーザー認証を行う。メールクライアントはメールを送信する前に、popで認証を行う。認証に成功したら、一定時間だけそのIPアドレスからメールを受け入れる
        - 暗号化機能
            - 暗号化はSMTPS(SMTP over ssl/tls)を使用。smtpsはhttpsと同じくssl/tlsで暗号化したプロトコル。
                - smtpsは最初にお互いがsmtpsに対応していることを「STARTTLS」というSMTPの拡張機能を利用して確認しあう
- メール受信プロトコル
    - POP3
        - POP3はtcpの110番を使用して通信を行う
        - メールソフトはメールサーバー(pop3サーバー)からメールを取り出すときにpop3を使用する
        - smptはデータを送信したいときに送信するプッシュ型のプロトコル。
        - 最後の受信だけプル型のプロトコルであるpop3を使用
        - 暗号化機能
            - SPOPとPOP3Sの2種類ある
    - IMAP4
        - TCPの143番を使用
        - imp4はメールをメールボックスから取り出す点はpop3と大きく変わらないが、メールをメールサーバーに残すという点が大きく異なる
            - pop3はメールをメールサーバーからダウンロードして、メールソフトで保存管理する。基本的にメールサーバーのメールは削除される
            - imp4はメールをメールサーバーに残したまま、メールソフトで閲覧する。
        - 暗号化機能
            - imap4sを使用
    - pop3
        - メリット サーバーのストレージ領域を節約できる。オフラインでもメールを管理できる
        - デメリット　端末のストレージ領域圧迫。複数の端末でメールを一元に管理できない
    - imap4
        - メリット 端末のストレージ領域節約 複数の端末でメールを一元管理できる
        - デメリット サーバーのストレージ領域圧迫 オフラインではメール管理できない
- Webメール
    - GmailやTahooメールなどがこれ
    - 以下はwebメールの送受信の流れ
        - webブラウザを使用して、webメールサーバーにhttpsでアクセス。このときユーザーIDとパスワードで認証。webブラウザ上でメールを作成し、送信ボタンをクリックすると、メールがhttpsでpopされる
        - webメールサーバーはDNSで相手先のwebメールサーバーのIPアドレスを探し、そのIPに対してsmtpメールで転送
        - 相手先のwebメールサーバーは受け取ったメールをユーザーごとに用意されたメールボックスに格納
        - 宛先メールアドレスのユーザーはwebブラウザを使用してwebメールサーバーにアクセス。ユーザーIDとパスワードで認証を行い、メールボックスの情報をhttpsでGet

### 管理アクセスプロトコル

- 遠隔からネットワーク機器の情報をみたり設定したりするときに使用するプロトコル
- telnet
    - 管理アクセスプロトコル。数あるアプリケーションプロトコルの中でも最も原始的かつシンプルなプロトコルでアプリケーションヘッダーがなく、アプリケーションペイロードにコマンドやASCIIコードのテキストデータをそのまま格納
    - パスワードを含む、すべてのデータが暗号化されずに平文でやりとりされるため、途中経路で盗聴できてしまうというセキュリティ上の問題がある
- ssh
    - telnetに暗号化や公開鍵認証、メッセージ認証などの機能に加えてパワーアップさせたもの
    - ファイル転送
        - sshを利用したファイル転送機能はscpとsftpの2種つい
    - ポートフォワーディング
        - 特定のポート番号に対する通信をsshで作った暗号化通信路を使用して別端末に転送する機能。
        - 実際の現場でポートフォワーディングが役立つケースとして、cli環境しか提供していない踏み台サーバー経由で、目的のサーバーやネットワーク機器にGUIでログインしたい時。踏み台サーバーはサーバーやネットワーク機器にログインするために踏み台となって、パケットを中継するサーバーのこと

### 運用管理プロトコル

- NTP
    - ネットワーク機器やサーバーの時刻を合わせるために使用するプロトコル。
    - NTPの階層構造
        - ストレイタムという値を用いた階層構造
- SNMP
    - ネットワーク機器やサーバーの性能監視や障害監視で使用されるプロトコル
    - cpu使用率やメモリ使用率、トラフィック量、パケット量など定期的に収集、継続的に監視する
    - 有名な製品としてZabbix
- Syslog
    - ネットワーク機器やサーバーのログを転送するために使用されるプロトコル。
    - 何かのイベントが発生したら、それを自身のメモリやディスクに保存すると同時にsyslogサーバーへ転送するだけ
    - tcpはほぼ使われず、udpが使用されている
    - syslogメッセージはpri,ヘッダー,メッセージの3フィールドで構成されている
    - priはFacilityとseverityで構成されている
    - Facility
        - ログメッセージの種類を表す。kern,user,main,auth,syslog,cron,ftpなど
    - Severity
        - ログメッセージの重要度を表す。どのSeverity以上のメッセージをSyslogサーバーに送信するか、どのSeverity以上のメッセージをどのくらい保持するかを定義する
        - 例えばwarning以上をSyslogサーバーに送信し、notice以上を40960バイトまでバッファに保持するといった定義

### 冗長化プロトコル

- 物理層の冗長化技術
    - リンクアグリゲージョン
    - チーミング
- データリンク層の冗長化技術
    - stp
- ネットワーク層の冗長化技術
    - FHRP
        - サーバーやpcのファーストホップ、つまりデフォルトゲートウェイを冗長化する時に使用
        - 複数のデフォルトゲートウェイを一つの仮想的なデフォルトゲートウェイのように動作させることによって冗長化を図る
        - 特定のオブジェクトの状態を監視し、障害と判定したらプライオリティを下げるトラッキングという機能を持っている。監視しているオブジェクトに障害が発生したら、プライオリティを下げた生死監視パケットを送信して、フェイルオーバーを促す
        - ファイアウォールの冗長化技術
            - 基本的にfhrpと大きく変わらない
        - 負荷分散装置の冗長化技術
            - 基本的にファイアウォールと変わらない

### ALGプロトコル

- アプリケーションレベルの情報をもとに通信を制御する、ファイアウォールや負荷分散装置の機能のこと。通信途中でポート番号が変わってしまうようなプロトコルをファイアウォールや負荷分散装置で処理する時はALG機能が必要
- ftp
    - ファイル転送用アプリケーションプロトコル
- tftp
    - udpでファイルを転送するためのプロトコル
    - 暗号化機能がないためインターネットでつかわれることはほぼない
- sip
    - IP電話の呼制御を行うプロトコル
    - 呼とは電話をかけたり、切ったりするための処理
